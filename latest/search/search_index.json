{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nMonteCarlo.jl\n is a Julia software library for the simulation of physical models by means of the Markov Chain Monte Carlo technique. The package implements classical and quantum Monte Carlo flavors which can be used to study spin systems, interacting fermions, and boson-fermion mixtures.\n\n\n\n\nIncluded models:\n\n\n\n\nIsing model\n\n\nAttractive Hubbard model\n\n\n\n\n\n\nIncluded Monte Carlo flavors\n\n\n\n\nClassical Monte Carlo\n\n\nDeterminant Quantum Monte Carlo (also known as auxiliary field Monte Carlo)\n\n\n\n\n\n\nIncluded lattices\n\n\n\n\nCubic lattices (chain, square, cube, ...)\n\n\nAny ALPS lattice\n\n\n\n\nHave a look at the \nShowcase\n section to get some inspiration. \n\n\n\n\nStudy your own model\n\n\nA major idea behind the design of the package is convenient customization. Users should be able to define their own custom physical models (or extend existing ones) and explore their physics through Monte Carlo simulations. We hope that \nMonteCarlo.jl\n allows the user to put his focus on his physical model rather than tedious implementations of Monte Carlo schemes.\n\n\nTo that end, each (quantum) Monte Carlo flavor has a well-defined model interfaces, i.e. a precise specification of mandatory and optional fields and methods. An example can be found here: \nInterface: Monte Carlo (MC)\n. Practically, it makes sense to start by taking a look at the implementation of one of the predefined models.\n\n\nIf you implement a custom model that might be worth being added to the collection of supplied models, please consider creating a \npull request\n!\n\n\n\n\nGitHub\n\n\nMonteCarlo.jl\n is \nopen-source\n. The source code can be found on \ngithub\n. Criticism and contributions are very much welcome - just \nopen an issue\n. For more details see the \nContribution Guide\n.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "MonteCarlo.jl  is a Julia software library for the simulation of physical models by means of the Markov Chain Monte Carlo technique. The package implements classical and quantum Monte Carlo flavors which can be used to study spin systems, interacting fermions, and boson-fermion mixtures.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#included-models", 
            "text": "Ising model  Attractive Hubbard model", 
            "title": "Included models:"
        }, 
        {
            "location": "/#included-monte-carlo-flavors", 
            "text": "Classical Monte Carlo  Determinant Quantum Monte Carlo (also known as auxiliary field Monte Carlo)", 
            "title": "Included Monte Carlo flavors"
        }, 
        {
            "location": "/#included-lattices", 
            "text": "Cubic lattices (chain, square, cube, ...)  Any ALPS lattice   Have a look at the  Showcase  section to get some inspiration.", 
            "title": "Included lattices"
        }, 
        {
            "location": "/#study-your-own-model", 
            "text": "A major idea behind the design of the package is convenient customization. Users should be able to define their own custom physical models (or extend existing ones) and explore their physics through Monte Carlo simulations. We hope that  MonteCarlo.jl  allows the user to put his focus on his physical model rather than tedious implementations of Monte Carlo schemes.  To that end, each (quantum) Monte Carlo flavor has a well-defined model interfaces, i.e. a precise specification of mandatory and optional fields and methods. An example can be found here:  Interface: Monte Carlo (MC) . Practically, it makes sense to start by taking a look at the implementation of one of the predefined models.  If you implement a custom model that might be worth being added to the collection of supplied models, please consider creating a  pull request !", 
            "title": "Study your own model"
        }, 
        {
            "location": "/#github", 
            "text": "MonteCarlo.jl  is  open-source . The source code can be found on  github . Criticism and contributions are very much welcome - just  open an issue . For more details see the  Contribution Guide .", 
            "title": "GitHub"
        }, 
        {
            "location": "/manual/gettingstarted/", 
            "text": "Getting Started\n\n\n\n\nInstallation\n\n\nMonteCarlo.jl\n hasn't yet been released. To clone the package execute the following command in the Julia REPL:\n\n\nPkg\n.\nclone\n(\nhttps://github.com/crstnbr/MonteCarlo.jl\n)\n\n\n\n\n\n\nTo update to the latest version of the package just do \nPkg.update()\n or specifically \nPkg.update(\"MonteCarlo\")\n.\n\n\n\n\nWarning\n\n\nThe package is still in pre-alpha phase and shouldn't yet be used for production runs.\n\n\n\n\n\n\nUsage\n\n\nThis is a simple demontration of how to perform a Monte Carlo simulation of the 2D Ising model:\n\n\n# load packages\n\n\nusing\n \nMonteCarlo\n,\n \nMonteCarloObservable\n\n\n\n# load your model\n\n\nm\n \n=\n \nIsingModel\n(\ndims\n=\n2\n,\n \nL\n=\n8\n);\n\n\n\n# choose a Monte Carlo flavor and run the simulation\n\n\nmc\n \n=\n \nMC\n(\nm\n,\n \nbeta\n=\n0.35\n);\n\n\nrun!\n(\nmc\n,\n \nsweeps\n=\n1000\n,\n \nthermalization\n=\n1000\n,\n \nverbose\n=\nfalse\n);\n\n\n\n# analyze results\n\n\nobservables\n(\nmc\n)\n \n# what observables do exist for that simulation?\n\n\nm\n \n=\n \nmc\n.\nobs\n[\nm\n]\n \n# magnetization\n\n\nmean\n(\nm\n)\n\n\nstd\n(\nm\n)\n \n# one-sigma error\n\n\n\n# create standard plots\n\n\nhist\n(\nm\n)\n\n\nplot\n(\nm\n)", 
            "title": "Getting started"
        }, 
        {
            "location": "/manual/gettingstarted/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/manual/gettingstarted/#installation", 
            "text": "MonteCarlo.jl  hasn't yet been released. To clone the package execute the following command in the Julia REPL:  Pkg . clone ( https://github.com/crstnbr/MonteCarlo.jl )   To update to the latest version of the package just do  Pkg.update()  or specifically  Pkg.update(\"MonteCarlo\") .   Warning  The package is still in pre-alpha phase and shouldn't yet be used for production runs.", 
            "title": "Installation"
        }, 
        {
            "location": "/manual/gettingstarted/#usage", 
            "text": "This is a simple demontration of how to perform a Monte Carlo simulation of the 2D Ising model:  # load packages  using   MonteCarlo ,   MonteCarloObservable  # load your model  m   =   IsingModel ( dims = 2 ,   L = 8 );  # choose a Monte Carlo flavor and run the simulation  mc   =   MC ( m ,   beta = 0.35 );  run! ( mc ,   sweeps = 1000 ,   thermalization = 1000 ,   verbose = false );  # analyze results  observables ( mc )   # what observables do exist for that simulation?  m   =   mc . obs [ m ]   # magnetization  mean ( m )  std ( m )   # one-sigma error  # create standard plots  hist ( m )  plot ( m )", 
            "title": "Usage"
        }, 
        {
            "location": "/manual/showcase/", 
            "text": "Showcase\n\n\n\n\n2D Ising model\n\n\nResults:\n \n\n\nCode:\n\n\nusing\n \nMonteCarlo\n,\n \nDistributions\n,\n \nPyPlot\n,\n \nDataFrames\n,\n \nJLD\n\n\n\nTdist\n \n=\n \nNormal\n(\nMonteCarlo\n.\nIsingTc\n,\n \n.\n64\n)\n\n\nn_Ts\n \n=\n \n2\n^\n8\n\n\nTs\n \n=\n \nsort!\n(\nrand\n(\nTdist\n,\n \nn_Ts\n))\n\n\nTs\n \n=\n \nTs\n[\nTs\n.\n=\n1.2\n]\n\n\nTs\n \n=\n \nTs\n[\nTs\n.\n=\n3.8\n]\n\n\ntherm\n \n=\n \n10\n^\n4\n\n\nsweeps\n \n=\n \n10\n^\n3\n\n\n\ndf\n \n=\n \nDataFrame\n(\nL\n=\nInt\n[],\n \nT\n=\nFloat64\n[],\n \nM\n=\nFloat64\n[],\n \n\u03c7\n=\nFloat64\n[],\n \nE\n=\nFloat64\n[],\n \nC_V\n=\nFloat64\n[])\n\n\n\nfor\n \nL\n \nin\n \n2.\n^\n[\n3\n,\n \n4\n,\n \n5\n,\n \n6\n]\n\n    \nprintln\n(\nL = \n,\n \nL\n)\n\n    \nfor\n \n(\ni\n,\n \nT\n)\n \nin\n \nenumerate\n(\nTs\n)\n\n        \nprintln\n(\n\\t\n T = \n,\n \nT\n)\n\n        \nbeta\n \n=\n \n1\n/\nT\n\n        \nmodel\n \n=\n \nIsingModel\n(\ndims\n=\n2\n,\n \nL\n=\nL\n)\n\n        \nmc\n \n=\n \nMC\n(\nmodel\n,\n \nbeta\n=\nbeta\n)\n\n        \nrun!\n(\nmc\n,\n \nsweeps\n=\nsweeps\n,\n \nthermalization\n=\ntherm\n,\n \nverbose\n=\nfalse\n)\n\n        \npush!\n(\ndf\n,\n \n[\nL\n,\n \nT\n,\n \nmean\n(\nmc\n.\nobs\n[\nm\n]),\n \nmean\n(\nmc\n.\nobs\n[\n\u03c7\n]),\n \nmean\n(\nmc\n.\nobs\n[\ne\n]),\n \nmean\n(\nmc\n.\nobs\n[\nC\n])])\n\n    \nend\n\n    \nflush\n(\nSTDOUT\n)\n\n\nend\n\n\n\nsort!\n(\ndf\n,\n \ncols\n \n=\n \n[\n:\nL\n,\n \n:\nT\n])\n\n\n@save\n \nising2d.jld\n \ndf\n\n\n\n# plot results together\n\n\ngrps\n \n=\n \ngroupby\n(\ndf\n,\n \n:\nL\n)\n\n\nfig\n,\n \nax\n \n=\n \nsubplots\n(\n2\n,\n2\n,\n \nfigsize\n=\n(\n12\n,\n8\n))\n\n\nfor\n \ng\n \nin\n \ngrps\n\n    \nL\n \n=\n \ng\n[\n:\nL\n][\n1\n]\n\n    \nax\n[\n1\n][\n:\nplot\n](\ng\n[\n:\nT\n],\n \ng\n[\n:\nE\n],\n \no\n,\n \nmarkeredgecolor\n=\nblack\n,\n \nlabel\n=\nL=\n$L\n)\n\n    \nax\n[\n2\n][\n:\nplot\n](\ng\n[\n:\nT\n],\n \ng\n[\n:\nC_V\n],\n \no\n,\n \nmarkeredgecolor\n=\nblack\n,\n \nlabel\n=\nL=\n$L\n)\n\n    \nax\n[\n3\n][\n:\nplot\n](\ng\n[\n:\nT\n],\n \ng\n[\n:\nM\n],\n \no\n,\n \nmarkeredgecolor\n=\nblack\n,\n \nlabel\n=\nL=\n$L\n)\n\n    \nax\n[\n4\n][\n:\nplot\n](\ng\n[\n:\nT\n],\n \ng\n[\n:\n\u03c7\n],\n \no\n,\n \nmarkeredgecolor\n=\nblack\n,\n \nlabel\n=\nL=\n$L\n)\n\n\nend\n\n\nax\n[\n1\n][\n:\nlegend\n](\nloc\n=\nbest\n)\n\n\nax\n[\n1\n][\n:\nset_ylabel\n](\nEnergy\n)\n\n\nax\n[\n1\n][\n:\nset_xlabel\n](\nTemperature\n)\n\n\n\nax\n[\n2\n][\n:\nset_ylabel\n](\nSpecific heat\n)\n\n\nax\n[\n2\n][\n:\nset_xlabel\n](\nTemperature\n)\n\n\nax\n[\n2\n][\n:\naxvline\n](\nx\n=\nMonteCarlo\n.\nIsingTc\n,\n \ncolor\n=\nblack\n,\n \nlinestyle\n=\ndashed\n,\n \nlabel\n=\n\\$\n T_c \n\\$\n)\n\n\nax\n[\n2\n][\n:\nlegend\n](\nloc\n=\nbest\n)\n\n\n\nax\n[\n3\n][\n:\nset_ylabel\n](\nMagnetization\n)\n\n\nax\n[\n3\n][\n:\nset_xlabel\n](\nTemperature\n)\n\n\nx\n \n=\n \nlinspace\n(\n1.2\n,\n \nMonteCarlo\n.\nIsingTc\n,\n \n100\n)\n\n\ny\n \n=\n \n(\n1\n-\nsinh\n.\n(\n2.0\n \n./\n \n(\nx\n))\n.^\n(\n-\n4\n))\n.^\n(\n1\n/\n8\n)\n\n\nax\n[\n3\n][\n:\nplot\n](\nx\n,\ny\n,\n \nk--\n,\n \nlabel\n=\nexact\n)\n\n\nax\n[\n3\n][\n:\nplot\n](\nlinspace\n(\nMonteCarlo\n.\nIsingTc\n,\n \n3.8\n,\n \n100\n),\n \nzeros\n(\n100\n),\n \nk--\n)\n\n\nax\n[\n3\n][\n:\nlegend\n](\nloc\n=\nbest\n)\n\n\n\nax\n[\n4\n][\n:\nset_ylabel\n](\nSusceptibility \u03c7\n)\n\n\nax\n[\n4\n][\n:\nset_xlabel\n](\nTemperature\n)\n\n\nax\n[\n4\n][\n:\naxvline\n](\nx\n=\nMonteCarlo\n.\nIsingTc\n,\n \ncolor\n=\nblack\n,\n \nlinestyle\n=\ndashed\n,\n \nlabel\n=\n\\$\n T_c \n\\$\n)\n\n\nax\n[\n4\n][\n:\nlegend\n](\nloc\n=\nbest\n)\n\n\ntight_layout\n()\n\n\nsavefig\n(\nising2d.pdf\n)", 
            "title": "Showcase"
        }, 
        {
            "location": "/manual/showcase/#showcase", 
            "text": "", 
            "title": "Showcase"
        }, 
        {
            "location": "/manual/showcase/#2d-ising-model", 
            "text": "Results:    Code:  using   MonteCarlo ,   Distributions ,   PyPlot ,   DataFrames ,   JLD  Tdist   =   Normal ( MonteCarlo . IsingTc ,   . 64 )  n_Ts   =   2 ^ 8  Ts   =   sort! ( rand ( Tdist ,   n_Ts ))  Ts   =   Ts [ Ts . = 1.2 ]  Ts   =   Ts [ Ts . = 3.8 ]  therm   =   10 ^ 4  sweeps   =   10 ^ 3  df   =   DataFrame ( L = Int [],   T = Float64 [],   M = Float64 [],   \u03c7 = Float64 [],   E = Float64 [],   C_V = Float64 [])  for   L   in   2. ^ [ 3 ,   4 ,   5 ,   6 ] \n     println ( L =  ,   L ) \n     for   ( i ,   T )   in   enumerate ( Ts ) \n         println ( \\t  T =  ,   T ) \n         beta   =   1 / T \n         model   =   IsingModel ( dims = 2 ,   L = L ) \n         mc   =   MC ( model ,   beta = beta ) \n         run! ( mc ,   sweeps = sweeps ,   thermalization = therm ,   verbose = false ) \n         push! ( df ,   [ L ,   T ,   mean ( mc . obs [ m ]),   mean ( mc . obs [ \u03c7 ]),   mean ( mc . obs [ e ]),   mean ( mc . obs [ C ])]) \n     end \n     flush ( STDOUT )  end  sort! ( df ,   cols   =   [ : L ,   : T ])  @save   ising2d.jld   df  # plot results together  grps   =   groupby ( df ,   : L )  fig ,   ax   =   subplots ( 2 , 2 ,   figsize = ( 12 , 8 ))  for   g   in   grps \n     L   =   g [ : L ][ 1 ] \n     ax [ 1 ][ : plot ]( g [ : T ],   g [ : E ],   o ,   markeredgecolor = black ,   label = L= $L ) \n     ax [ 2 ][ : plot ]( g [ : T ],   g [ : C_V ],   o ,   markeredgecolor = black ,   label = L= $L ) \n     ax [ 3 ][ : plot ]( g [ : T ],   g [ : M ],   o ,   markeredgecolor = black ,   label = L= $L ) \n     ax [ 4 ][ : plot ]( g [ : T ],   g [ : \u03c7 ],   o ,   markeredgecolor = black ,   label = L= $L )  end  ax [ 1 ][ : legend ]( loc = best )  ax [ 1 ][ : set_ylabel ]( Energy )  ax [ 1 ][ : set_xlabel ]( Temperature )  ax [ 2 ][ : set_ylabel ]( Specific heat )  ax [ 2 ][ : set_xlabel ]( Temperature )  ax [ 2 ][ : axvline ]( x = MonteCarlo . IsingTc ,   color = black ,   linestyle = dashed ,   label = \\$  T_c  \\$ )  ax [ 2 ][ : legend ]( loc = best )  ax [ 3 ][ : set_ylabel ]( Magnetization )  ax [ 3 ][ : set_xlabel ]( Temperature )  x   =   linspace ( 1.2 ,   MonteCarlo . IsingTc ,   100 )  y   =   ( 1 - sinh . ( 2.0   ./   ( x )) .^ ( - 4 )) .^ ( 1 / 8 )  ax [ 3 ][ : plot ]( x , y ,   k-- ,   label = exact )  ax [ 3 ][ : plot ]( linspace ( MonteCarlo . IsingTc ,   3.8 ,   100 ),   zeros ( 100 ),   k-- )  ax [ 3 ][ : legend ]( loc = best )  ax [ 4 ][ : set_ylabel ]( Susceptibility \u03c7 )  ax [ 4 ][ : set_xlabel ]( Temperature )  ax [ 4 ][ : axvline ]( x = MonteCarlo . IsingTc ,   color = black ,   linestyle = dashed ,   label = \\$  T_c  \\$ )  ax [ 4 ][ : legend ]( loc = best )  tight_layout ()  savefig ( ising2d.pdf )", 
            "title": "2D Ising model"
        }, 
        {
            "location": "/models/ising/", 
            "text": "Ising Model\n\n\n\n\nHamiltonian\n\n\nThe famous Hamiltonian of the Ising model is given by\n\n\n\n\n\\begin{align} \\mathcal{H} = -\\sum_{\\langle i,j \\rangle} \\sigma_i \\sigma_j , \\end{align}\n\n\n\\begin{align} \\mathcal{H} = -\\sum_{\\langle i,j \\rangle} \\sigma_i \\sigma_j , \\end{align}\n\n\n\n\nwhere \n\\langle i, j \\rangle\n\\langle i, j \\rangle\n indicates that the sum has to be taken over nearest neighbors.\n\n\n\n\nCreating an Ising model\n\n\nYou can create an Ising model as follows,\n\n\nmodel\n \n=\n \nIsingModel\n(;\n \ndims\n::\nInt\n=\n2\n,\n \nL\n::\nInt\n=\n8\n)\n\n\n\n\n\n\nThe following parameters can be set via keyword arguments:\n\n\n\n\ndims\n: dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.)\n\n\nL\n: linear system size\n\n\n\n\n\n\nSupported Monte Carlo flavors\n\n\n\n\nMonte Carlo (MC)\n (Have a look at the examples section below)\n\n\n\n\n\n\nExamples\n\n\nYou can find example simulations of the 2D Ising model under \nGetting started\n and here: \n2D Ising model\n.\n\n\n\n\nExports\n\n\n#\n\n\nMonteCarlo.IsingModel\n \n \nType\n.\n\n\nFamous Ising model on a cubic lattice.\n\n\nIsingModel(; dims, L)\n\n\n\n\n\nCreate Ising model on \ndims\n-dimensional cubic lattice with linear system size \nL\n.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.IsingModel\n \n \nMethod\n.\n\n\nIsingModel(kwargs::Dict{String, Any})\n\n\n\n\n\nCreate Ising model with (keyword) parameters as specified in \nkwargs\n dict.\n\n\nsource\n\n\n\n\nAnalytic results\n\n\n\n\nSquare lattice (2D)\n\n\nThe model can be solved exactly by transfer matrix method (\nOnsager solution\n). This gives the following results.\n\n\nCritical temperature: \nT_c = \\frac{2}{\\ln{1+\\sqrt{2}}}\nT_c = \\frac{2}{\\ln{1+\\sqrt{2}}}\n\n\nMagnetization (per site): \nm = \\left(1-\\left[\\sinh 2\\beta \\right]^{-4}\\right)^{\\frac {1}{8}}\nm = \\left(1-\\left[\\sinh 2\\beta \\right]^{-4}\\right)^{\\frac {1}{8}}\n\n\n\n\nPotential extensions\n\n\nPull requests are very much welcome!\n\n\n\n\nArbitrary dimensions\n\n\nMagnetic field\n\n\nMaybe explicit \nJ\nJ\n instead of implicit \nJ=1\nJ=1\n\n\nNon-cubic lattices (just add \nlattice::Lattice\n keyword)", 
            "title": "Ising Model"
        }, 
        {
            "location": "/models/ising/#ising-model", 
            "text": "", 
            "title": "Ising Model"
        }, 
        {
            "location": "/models/ising/#hamiltonian", 
            "text": "The famous Hamiltonian of the Ising model is given by   \\begin{align} \\mathcal{H} = -\\sum_{\\langle i,j \\rangle} \\sigma_i \\sigma_j , \\end{align}  \\begin{align} \\mathcal{H} = -\\sum_{\\langle i,j \\rangle} \\sigma_i \\sigma_j , \\end{align}   where  \\langle i, j \\rangle \\langle i, j \\rangle  indicates that the sum has to be taken over nearest neighbors.", 
            "title": "Hamiltonian"
        }, 
        {
            "location": "/models/ising/#creating-an-ising-model", 
            "text": "You can create an Ising model as follows,  model   =   IsingModel (;   dims :: Int = 2 ,   L :: Int = 8 )   The following parameters can be set via keyword arguments:   dims : dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.)  L : linear system size", 
            "title": "Creating an Ising model"
        }, 
        {
            "location": "/models/ising/#supported-monte-carlo-flavors", 
            "text": "Monte Carlo (MC)  (Have a look at the examples section below)", 
            "title": "Supported Monte Carlo flavors"
        }, 
        {
            "location": "/models/ising/#examples", 
            "text": "You can find example simulations of the 2D Ising model under  Getting started  and here:  2D Ising model .", 
            "title": "Examples"
        }, 
        {
            "location": "/models/ising/#exports", 
            "text": "#  MonteCarlo.IsingModel     Type .  Famous Ising model on a cubic lattice.  IsingModel(; dims, L)  Create Ising model on  dims -dimensional cubic lattice with linear system size  L .  source  #  MonteCarlo.IsingModel     Method .  IsingModel(kwargs::Dict{String, Any})  Create Ising model with (keyword) parameters as specified in  kwargs  dict.  source", 
            "title": "Exports"
        }, 
        {
            "location": "/models/ising/#analytic-results", 
            "text": "", 
            "title": "Analytic results"
        }, 
        {
            "location": "/models/ising/#square-lattice-2d", 
            "text": "The model can be solved exactly by transfer matrix method ( Onsager solution ). This gives the following results.  Critical temperature:  T_c = \\frac{2}{\\ln{1+\\sqrt{2}}} T_c = \\frac{2}{\\ln{1+\\sqrt{2}}}  Magnetization (per site):  m = \\left(1-\\left[\\sinh 2\\beta \\right]^{-4}\\right)^{\\frac {1}{8}} m = \\left(1-\\left[\\sinh 2\\beta \\right]^{-4}\\right)^{\\frac {1}{8}}", 
            "title": "Square lattice (2D)"
        }, 
        {
            "location": "/models/ising/#potential-extensions", 
            "text": "Pull requests are very much welcome!   Arbitrary dimensions  Magnetic field  Maybe explicit  J J  instead of implicit  J=1 J=1  Non-cubic lattices (just add  lattice::Lattice  keyword)", 
            "title": "Potential extensions"
        }, 
        {
            "location": "/models/hubbardattractive/", 
            "text": "Attractive Hubbard Model\n\n\n\n\nHamiltonian\n\n\nThe Hamiltonian of the attractive (negative \nU\nU\n) Hubbard model reads\n\n\n\n\n\\begin{align} \\mathcal{H} = -t \\sum_{\\langle i,j \\rangle, \\sigma} \\left( c^\\dagger_{i\\sigma} c_{j\\sigma} + \\text{h.c.} \\right) - |U| \\sum_j \\left( n_{j\\uparrow} - \\frac{1}{2} \\right) \\left( n_{j\\downarrow} - \\frac{1}{2} \\right) - \\mu\\sum_j n_{j}, \\end{align}\n\n\n\\begin{align} \\mathcal{H} = -t \\sum_{\\langle i,j \\rangle, \\sigma} \\left( c^\\dagger_{i\\sigma} c_{j\\sigma} + \\text{h.c.} \\right) - |U| \\sum_j \\left( n_{j\\uparrow} - \\frac{1}{2} \\right) \\left( n_{j\\downarrow} - \\frac{1}{2} \\right) - \\mu\\sum_j n_{j}, \\end{align}\n\n\n\n\nwhere \n\\sigma\n\\sigma\n denotes spin, \nt\nt\n is the hopping amplitude, \nU\nU\n the on-site repulsive interaction strength, \n\\mu\n\\mu\n the chemical potential and \n\\langle i, j \\rangle\n\\langle i, j \\rangle\n indicates that the sum has to be taken over nearest neighbors. Note that (1) is written in particle-hole symmetric form such that \n\\mu = 0\n\\mu = 0\n corresponds to half-filling.\n\n\n\n\nConstructor\n\n\nYou can create an attractive Hubbard model instance as follows,\n\n\nmodel\n \n=\n \nHubbardModelAttractive\n(\ndims\n=\n1\n,\n \nL\n=\n8\n)\n\n\n\n\n\n\nThe following parameters can be set via keyword arguments:\n\n\n\n\ndims::Int\n: dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.)\n\n\nL::Int\n: linear system size\n\n\nt::Float64 = 1.0\n: hopping energy\n\n\nU::Float64 = 1.0\n: onsite interaction strength, \"Hubbard \nU\nU\n\"\n\n\nmu::Float64 = 0.0\n: chemical potential\n\n\n\n\n\n\nSupported Monte Carlo flavors\n\n\n\n\nDeterminant Quantum Monte Carlo (DQMC)\n, see details below\n\n\n\n\n\n\nDQMC formulation\n\n\nWe decouple the onsite electron-electron interaction by performing a Hirsch transformation, i.e. a discrete Hubbard-Stratonovich transformation in the density/charge channel,\n\n\n\n\n\\begin{align} e^{|U|\\Delta \\tau \\left( n_{i\\uparrow} - \\frac{1}{2} \\right) \\left(n_{i\\downarrow} - \\frac{1}{2} \\right)} = \\frac{1}{2} e^{-|U|\\Delta \\tau /4} \\sum_{s=\\pm 1} \\prod_{\\sigma=\\pm 1} e^{s\\lambda (n_{i\\sigma}-\\frac{1}{2})}. \\end{align}\n\n\n\\begin{align} e^{|U|\\Delta \\tau \\left( n_{i\\uparrow} - \\frac{1}{2} \\right) \\left(n_{i\\downarrow} - \\frac{1}{2} \\right)} = \\frac{1}{2} e^{-|U|\\Delta \\tau /4} \\sum_{s=\\pm 1} \\prod_{\\sigma=\\pm 1} e^{s\\lambda (n_{i\\sigma}-\\frac{1}{2})}. \\end{align}\n\n\n\n\nThe interaction matrix of the model then reads\n\n\n\n\n\\begin{align} V_{ij}(l) \n= \\delta_{ij} V_i(l), \\\\\nV_i(l) \n= - \\frac{1}{\\Delta \\tau} \\lambda s_i(l). \\end{align}\n\n\n\\begin{align} V_{ij}(l) &= \\delta_{ij} V_i(l), \\\\\nV_i(l) &= - \\frac{1}{\\Delta \\tau} \\lambda s_i(l). \\end{align}\n\n\n\n\nFor completeness, the hopping matrix is \n\\begin{align} T_{ij} &= \\begin{cases} -t & \\text{if i and j are nearest neighbors,} \\\\\n-\\mu & \\text{if i == j,} \\\\\n0 & \\text{otherwise.} \\end{cases} \\end{align}\n\n\n\n\nAs neither \nT\nT\n nor \nV\nV\n depend on spin, neither does the equal-times Green's function. We can therefore restrict our computations to one spin flavor (\nflv=1\n) and benefit from operating with smaller matrices.\n\n\n\n\nPotential extensions\n\n\nPull requests are very much welcome!\n\n\n\n\nArbitrary lattices (so far only cubic lattices supported)", 
            "title": "Attractive Hubbard Model"
        }, 
        {
            "location": "/models/hubbardattractive/#attractive-hubbard-model", 
            "text": "", 
            "title": "Attractive Hubbard Model"
        }, 
        {
            "location": "/models/hubbardattractive/#hamiltonian", 
            "text": "The Hamiltonian of the attractive (negative  U U ) Hubbard model reads   \\begin{align} \\mathcal{H} = -t \\sum_{\\langle i,j \\rangle, \\sigma} \\left( c^\\dagger_{i\\sigma} c_{j\\sigma} + \\text{h.c.} \\right) - |U| \\sum_j \\left( n_{j\\uparrow} - \\frac{1}{2} \\right) \\left( n_{j\\downarrow} - \\frac{1}{2} \\right) - \\mu\\sum_j n_{j}, \\end{align}  \\begin{align} \\mathcal{H} = -t \\sum_{\\langle i,j \\rangle, \\sigma} \\left( c^\\dagger_{i\\sigma} c_{j\\sigma} + \\text{h.c.} \\right) - |U| \\sum_j \\left( n_{j\\uparrow} - \\frac{1}{2} \\right) \\left( n_{j\\downarrow} - \\frac{1}{2} \\right) - \\mu\\sum_j n_{j}, \\end{align}   where  \\sigma \\sigma  denotes spin,  t t  is the hopping amplitude,  U U  the on-site repulsive interaction strength,  \\mu \\mu  the chemical potential and  \\langle i, j \\rangle \\langle i, j \\rangle  indicates that the sum has to be taken over nearest neighbors. Note that (1) is written in particle-hole symmetric form such that  \\mu = 0 \\mu = 0  corresponds to half-filling.", 
            "title": "Hamiltonian"
        }, 
        {
            "location": "/models/hubbardattractive/#constructor", 
            "text": "You can create an attractive Hubbard model instance as follows,  model   =   HubbardModelAttractive ( dims = 1 ,   L = 8 )   The following parameters can be set via keyword arguments:   dims::Int : dimensionality of the cubic lattice (i.e. 1 = chain, 2 = square lattice, etc.)  L::Int : linear system size  t::Float64 = 1.0 : hopping energy  U::Float64 = 1.0 : onsite interaction strength, \"Hubbard  U U \"  mu::Float64 = 0.0 : chemical potential", 
            "title": "Constructor"
        }, 
        {
            "location": "/models/hubbardattractive/#supported-monte-carlo-flavors", 
            "text": "Determinant Quantum Monte Carlo (DQMC) , see details below", 
            "title": "Supported Monte Carlo flavors"
        }, 
        {
            "location": "/models/hubbardattractive/#dqmc-formulation", 
            "text": "We decouple the onsite electron-electron interaction by performing a Hirsch transformation, i.e. a discrete Hubbard-Stratonovich transformation in the density/charge channel,   \\begin{align} e^{|U|\\Delta \\tau \\left( n_{i\\uparrow} - \\frac{1}{2} \\right) \\left(n_{i\\downarrow} - \\frac{1}{2} \\right)} = \\frac{1}{2} e^{-|U|\\Delta \\tau /4} \\sum_{s=\\pm 1} \\prod_{\\sigma=\\pm 1} e^{s\\lambda (n_{i\\sigma}-\\frac{1}{2})}. \\end{align}  \\begin{align} e^{|U|\\Delta \\tau \\left( n_{i\\uparrow} - \\frac{1}{2} \\right) \\left(n_{i\\downarrow} - \\frac{1}{2} \\right)} = \\frac{1}{2} e^{-|U|\\Delta \\tau /4} \\sum_{s=\\pm 1} \\prod_{\\sigma=\\pm 1} e^{s\\lambda (n_{i\\sigma}-\\frac{1}{2})}. \\end{align}   The interaction matrix of the model then reads   \\begin{align} V_{ij}(l)  = \\delta_{ij} V_i(l), \\\\\nV_i(l)  = - \\frac{1}{\\Delta \\tau} \\lambda s_i(l). \\end{align}  \\begin{align} V_{ij}(l) &= \\delta_{ij} V_i(l), \\\\\nV_i(l) &= - \\frac{1}{\\Delta \\tau} \\lambda s_i(l). \\end{align}   For completeness, the hopping matrix is  \\begin{align} T_{ij} &= \\begin{cases} -t & \\text{if i and j are nearest neighbors,} \\\\\n-\\mu & \\text{if i == j,} \\\\\n0 & \\text{otherwise.} \\end{cases} \\end{align}   As neither  T T  nor  V V  depend on spin, neither does the equal-times Green's function. We can therefore restrict our computations to one spin flavor ( flv=1 ) and benefit from operating with smaller matrices.", 
            "title": "DQMC formulation"
        }, 
        {
            "location": "/models/hubbardattractive/#potential-extensions", 
            "text": "Pull requests are very much welcome!   Arbitrary lattices (so far only cubic lattices supported)", 
            "title": "Potential extensions"
        }, 
        {
            "location": "/flavors/mc/", 
            "text": "Monte Carlo (MC)\n\n\nThis is plain simple Monte Carlo (MC). It can for example be used to simulate the Ising model (see \n2D Ising model\n).\n\n\nYou can initialize a Monte Carlo simulation of a given \nmodel\n simply through\n\n\nmc\n \n=\n \nMC\n(\nmodel\n)\n\n\n\n\n\n\nAllowed keywords are:\n\n\n\n\nbeta\n: inverse temperature\n\n\nsweeps\n: number of measurement sweeps\n\n\nthermalization\n: number of thermalization (warmup) sweeps\n\n\nglobal_moves\n: wether global moves should be proposed\n\n\nglobal_rate\n: frequency for proposing global moves\n\n\nseed\n: initialize MC with custom seed\n\n\n\n\nAfterwards, you can run the simulation by\n\n\nrun!\n(\nmc\n)\n\n\n\n\n\n\nNote that you can just do another \nrun!(mc, sweeps=1000)\n to continue the simulation.\n\n\n\n\nExamples\n\n\nYou can find example simulations of the 2D Ising model under \nGetting started\n and here: \n2D Ising model\n.\n\n\n\n\nExports\n\n\n#\n\n\nMonteCarlo.greens\n \n \nMethod\n.\n\n\ngreens(mc::DQMC)\n\n\n\n\n\nObtain the current equal-time Green's function.\n\n\nInternally, \nmc.s.greens\n is an effective Green's function. This method transforms  this effective one to the actual Green's function by multiplying hopping matrix  exponentials from left and right.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.run!\n \n \nMethod\n.\n\n\nrun\n!(\nmc\n::\nDQMC\n[\n;\n \nverbose\n::Bool\n=\ntrue\n,\n \nsweeps\n::Int\n,\n \nthermalization\n::Int\n]\n)\n\n\n\n\n\n\nRuns the given Monte Carlo simulation \nmc\n. Progress will be printed to \nSTDOUT\n if \nverbose=true\n (default).\n\n\nsource\n\n\n#\n\n\nMonteCarlo.run!\n \n \nMethod\n.\n\n\nrun\n!(\nmc\n::\nMC\n[\n;\n \nverbose\n::Bool\n=\ntrue\n,\n \nsweeps\n::Int\n,\n \nthermalization\n::Int\n]\n)\n\n\n\n\n\n\nRuns the given Monte Carlo simulation \nmc\n. Progress will be printed to \nSTDOUT\n if \nverbose=true\n (default).\n\n\nsource\n\n\n#\n\n\nMonteCarlo.DQMC\n \n \nType\n.\n\n\nDeterminant quantum Monte Carlo (DQMC) simulation\n\n\nsource\n\n\n#\n\n\nMonteCarlo.DQMC\n \n \nMethod\n.\n\n\nDQMC\n(\nm\n::\nM\n;\n \nkwargs\n::\nDict\n{\nString,\n \nAny\n}\n)\n\n\n\n\n\n\nCreate a determinant quantum Monte Carlo simulation for model \nm\n with (keyword) parameters as specified in the dictionary \nkwargs\n.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.DQMC\n \n \nMethod\n.\n\n\nDQMC\n(\nm\n::\nM\n;\n \nkwargs\n...)\n \nwhere\n \nM\n:\nModel\n\n\n\n\n\n\nCreate a determinant quantum Monte Carlo simulation for model \nm\n with keyword parameters \nkwargs\n.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.MC\n \n \nType\n.\n\n\nMonte Carlo simulation\n\n\nsource\n\n\n#\n\n\nMonteCarlo.MC\n \n \nMethod\n.\n\n\nMC\n(\nm\n::\nM\n;\n \nkwargs\n::\nDict\n{\nString,\n \nAny\n}\n)\n\n\n\n\n\n\nCreate a Monte Carlo simulation for model \nm\n with (keyword) parameters as specified in the dictionary \nkwargs\n.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.MC\n \n \nMethod\n.\n\n\nMC\n(\nm\n::\nM\n;\n \nkwargs\n...)\n \nwhere\n \nM\n:\nModel\n\n\n\n\n\n\nCreate a Monte Carlo simulation for model \nm\n with keyword parameters \nkwargs\n.\n\n\nsource\n\n\n\n\nPotential extensions\n\n\nPull requests are very much welcome!\n\n\n\n\nHeat bath (instead of Metropolis) option", 
            "title": "MC"
        }, 
        {
            "location": "/flavors/mc/#monte-carlo-mc", 
            "text": "This is plain simple Monte Carlo (MC). It can for example be used to simulate the Ising model (see  2D Ising model ).  You can initialize a Monte Carlo simulation of a given  model  simply through  mc   =   MC ( model )   Allowed keywords are:   beta : inverse temperature  sweeps : number of measurement sweeps  thermalization : number of thermalization (warmup) sweeps  global_moves : wether global moves should be proposed  global_rate : frequency for proposing global moves  seed : initialize MC with custom seed   Afterwards, you can run the simulation by  run! ( mc )   Note that you can just do another  run!(mc, sweeps=1000)  to continue the simulation.", 
            "title": "Monte Carlo (MC)"
        }, 
        {
            "location": "/flavors/mc/#examples", 
            "text": "You can find example simulations of the 2D Ising model under  Getting started  and here:  2D Ising model .", 
            "title": "Examples"
        }, 
        {
            "location": "/flavors/mc/#exports", 
            "text": "#  MonteCarlo.greens     Method .  greens(mc::DQMC)  Obtain the current equal-time Green's function.  Internally,  mc.s.greens  is an effective Green's function. This method transforms  this effective one to the actual Green's function by multiplying hopping matrix  exponentials from left and right.  source  #  MonteCarlo.run!     Method .  run !( mc :: DQMC [ ;   verbose ::Bool = true ,   sweeps ::Int ,   thermalization ::Int ] )   Runs the given Monte Carlo simulation  mc . Progress will be printed to  STDOUT  if  verbose=true  (default).  source  #  MonteCarlo.run!     Method .  run !( mc :: MC [ ;   verbose ::Bool = true ,   sweeps ::Int ,   thermalization ::Int ] )   Runs the given Monte Carlo simulation  mc . Progress will be printed to  STDOUT  if  verbose=true  (default).  source  #  MonteCarlo.DQMC     Type .  Determinant quantum Monte Carlo (DQMC) simulation  source  #  MonteCarlo.DQMC     Method .  DQMC ( m :: M ;   kwargs :: Dict { String,   Any } )   Create a determinant quantum Monte Carlo simulation for model  m  with (keyword) parameters as specified in the dictionary  kwargs .  source  #  MonteCarlo.DQMC     Method .  DQMC ( m :: M ;   kwargs ...)   where   M : Model   Create a determinant quantum Monte Carlo simulation for model  m  with keyword parameters  kwargs .  source  #  MonteCarlo.MC     Type .  Monte Carlo simulation  source  #  MonteCarlo.MC     Method .  MC ( m :: M ;   kwargs :: Dict { String,   Any } )   Create a Monte Carlo simulation for model  m  with (keyword) parameters as specified in the dictionary  kwargs .  source  #  MonteCarlo.MC     Method .  MC ( m :: M ;   kwargs ...)   where   M : Model   Create a Monte Carlo simulation for model  m  with keyword parameters  kwargs .  source", 
            "title": "Exports"
        }, 
        {
            "location": "/flavors/mc/#potential-extensions", 
            "text": "Pull requests are very much welcome!   Heat bath (instead of Metropolis) option", 
            "title": "Potential extensions"
        }, 
        {
            "location": "/flavors/dqmc/", 
            "text": "Determinant Quantum Monte Carlo (DQMC)\n\n\nThis is determinant quantum Monte Carlo (MC) also known auxiliary field quantum Monte Carlo. It can be used to simulate interacting fermion systems, here the auxiliary boson arises from a Hubbard Stratonovich transformation, or fermions which are naturally coupled to bosons. An example is the \nAttractive Hubbard Model\n.\n\n\nYou can initialize a determinant quantum Monte Carlo simulation of a given \nmodel\n simply through\n\n\ndqmc\n \n=\n \nDQMC\n(\nmodel\n,\n \nbeta\n=\n5.0\n)\n\n\n\n\n\n\nMandatory keywords are:\n\n\n\n\nbeta\n: inverse temperature\n\n\n\n\nAllowed keywords are:\n\n\n\n\ndelta_tau::Float64 = 0.1\n: imaginary time step size\n\n\nsafe_mult::Int = 10\n: stabilize Green's function calculations every \nsafe_mult\n step (How many slice matrices can be multiplied until singular value information is lost due to numerical unaccuracy?)\n\n\ncheckerboard::Float64 = false\n: use \nCheckerboard decomposition\n (faster)\n\n\nsweeps\n: number of measurement sweeps\n\n\nthermalization\n: number of thermalization (warmup) sweeps\n\n\nseed\n: initialize DQMC with custom seed\n\n\nall_checks::Bool = true\n: turn off to suppress some numerical checks\n\n\n\n\nAfterwards, you can run the simulation by\n\n\nrun!\n(\ndqmc\n)\n\n\n\n\n\n\n\n\nTechnical details\n\n\n\n\nSymmetric Suzuki-Trotter decomposition\n\n\nWe use the symmetric version of the Suzuki-Trotter decomposition, i.e.\n\n\n\n\n\\begin{align} e^{-\\Delta\\tau \\sum_l T+V(l)} = \\prod_j e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V} e^{-\\Delta\\tau T/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}\n\n\n\\begin{align} e^{-\\Delta\\tau \\sum_l T+V(l)} = \\prod_j e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V} e^{-\\Delta\\tau T/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}\n\n\n\n\nwhere \nT\nT\n is the hopping matrix and \nV(l)\nV(l)\n is the interaction matrix with \nl\nl\n an imaginary time slice index indicating an auxiliary field dependence.\n\n\nWith the imaginary time slice matrices \nB_l = e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V(l)} e^{-\\Delta\\tau T/2}\nB_l = e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V(l)} e^{-\\Delta\\tau T/2}\n the equal-time Green's function is \nG = \\left( 1 + B_M \\cdots B_1 \\right)^{-1}\nG = \\left( 1 + B_M \\cdots B_1 \\right)^{-1}\n.\n\n\n\n\nCheckerboard decomposition\n\n\nWe provide a general algorithm to construct the \"checkerboard\" split up of a generic \nLattice\n. The only requirement is that the \nLattice\n has the following two fields,\n\n\n\n\nn_bonds::Int\n: total number of bonds (lattice graph edges)\n\n\nbonds::Matrix{Int}\n: bond matrix of shape \n(n_bonds, 3)\n. Rows correspond to bonds and columns indicate source site, target site, and bond type in this order.\n\n\n\n\nOf course, one can also manually construct a (more efficient) checkerboard split up by overloading the following function for the specific \nLattice\n subtype.\n\n\n#\n\n\nMonteCarlo.build_checkerboard\n \n \nMethod\n.\n\n\nbuild_checkerboard(l::Lattice) -\n checkerboard, groups, n_groups\n\n\nGeneric checkerboard construction.\n\n\nThe methods returns\n\n\n\n\ncheckerboard::Matrix{Int}\n: size \n(3, n_bonds)\n where               rows = \nsource site\n, \ntarget site\n, \nbondid\n and cols               correspond to bonds. Sorted (along columns) in such a way               that \ncheckerboard[3, groups[i]]\n are all the bond indices               corresponding to the i-th group.\n\n\ngroups::Vector{UnitRange}\n: ranges indicating which columns of \ncheckerboard\n                              belong to which checkerboard group.\n\n\nn_groups::Int\n: number of checkerboard groups.\n\n\n\n\nsource\n\n\n\n\nEffective slice matrices and Green's function\n\n\nCombining the symmetric Suzuki-Trotter and checkerboard decomposition we can write (assuming two checkerboard groups \na\na\n and \nb\nb\n)\n\n\n\n\n\\begin{align} e^{-\\Delta\\tau \\sum_l T+V(l)} \n= e^{\\Delta\\tau T_a/2} e^{\\Delta\\tau T_b/2} \\\\\n\n\\times \\left( \\prod_j e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a} e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau V} \\right) e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}\n\n\n\\begin{align} e^{-\\Delta\\tau \\sum_l T+V(l)} &= e^{\\Delta\\tau T_a/2} e^{\\Delta\\tau T_b/2} \\\\\n&\\times \\left( \\prod_j e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a} e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau V} \\right) e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}\n\n\n\n\nFor performance resons we internally work with effective imaginary time slice matrices\n\n\n\n\n\nB_l^{\\text{eff}} = e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a} e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau V}\n\n\n\n\nB_l^{\\text{eff}} = e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a} e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau V}\n\n\n\n\n\ninstead of the original \nB_l\nB_l\ns above.\n\n\n\n\nWarning\n\n\nNote that one consequence is that the field \ndqmc.s.greens\n isn't the actual Green's function but an effective one defined by \n\\begin{align} G &= \\left( 1 + B_M \\cdots B_1 \\right)^{-1} \\\\\n&= e^{\\Delta\\tau T_a/2} e^{\\Delta\\tau T_b/2} \\left( 1 + B^{\\text{eff}}_M \\cdots B^{\\text{eff}}_1 \\right)^{-1} e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a/2} \\\\\n&= e^{\\Delta\\tau T_a/2} e^{\\Delta\\tau T_b/2} G^{\\text{eff}} e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a/2} \\end{align}\n\n\n\n\nTo obtain the actual equal-times Green's function, for example for measuring, use \ngreens(dqmc::DQMC)\n. Note that although \nG\\overset{!}{=}G^\\text{eff}\nG\\overset{!}{=}G^\\text{eff}\n} one can readily show that \n\\det G = \\det G^{\\text{eff}}\n\\det G = \\det G^{\\text{eff}}\n holds and the Metropolis acceptance is not affected by switching to the effective matrices.\n\n\n\n\n\n\nExports\n\n\n\n\nPotential extensions\n\n\nPull requests are very much welcome!\n\n\n\n\ntodo", 
            "title": "DQMC"
        }, 
        {
            "location": "/flavors/dqmc/#determinant-quantum-monte-carlo-dqmc", 
            "text": "This is determinant quantum Monte Carlo (MC) also known auxiliary field quantum Monte Carlo. It can be used to simulate interacting fermion systems, here the auxiliary boson arises from a Hubbard Stratonovich transformation, or fermions which are naturally coupled to bosons. An example is the  Attractive Hubbard Model .  You can initialize a determinant quantum Monte Carlo simulation of a given  model  simply through  dqmc   =   DQMC ( model ,   beta = 5.0 )   Mandatory keywords are:   beta : inverse temperature   Allowed keywords are:   delta_tau::Float64 = 0.1 : imaginary time step size  safe_mult::Int = 10 : stabilize Green's function calculations every  safe_mult  step (How many slice matrices can be multiplied until singular value information is lost due to numerical unaccuracy?)  checkerboard::Float64 = false : use  Checkerboard decomposition  (faster)  sweeps : number of measurement sweeps  thermalization : number of thermalization (warmup) sweeps  seed : initialize DQMC with custom seed  all_checks::Bool = true : turn off to suppress some numerical checks   Afterwards, you can run the simulation by  run! ( dqmc )", 
            "title": "Determinant Quantum Monte Carlo (DQMC)"
        }, 
        {
            "location": "/flavors/dqmc/#technical-details", 
            "text": "", 
            "title": "Technical details"
        }, 
        {
            "location": "/flavors/dqmc/#symmetric-suzuki-trotter-decomposition", 
            "text": "We use the symmetric version of the Suzuki-Trotter decomposition, i.e.   \\begin{align} e^{-\\Delta\\tau \\sum_l T+V(l)} = \\prod_j e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V} e^{-\\Delta\\tau T/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}  \\begin{align} e^{-\\Delta\\tau \\sum_l T+V(l)} = \\prod_j e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V} e^{-\\Delta\\tau T/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}   where  T T  is the hopping matrix and  V(l) V(l)  is the interaction matrix with  l l  an imaginary time slice index indicating an auxiliary field dependence.  With the imaginary time slice matrices  B_l = e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V(l)} e^{-\\Delta\\tau T/2} B_l = e^{-\\Delta\\tau T/2} e^{-\\Delta\\tau V(l)} e^{-\\Delta\\tau T/2}  the equal-time Green's function is  G = \\left( 1 + B_M \\cdots B_1 \\right)^{-1} G = \\left( 1 + B_M \\cdots B_1 \\right)^{-1} .", 
            "title": "Symmetric Suzuki-Trotter decomposition"
        }, 
        {
            "location": "/flavors/dqmc/#checkerboard-decomposition", 
            "text": "We provide a general algorithm to construct the \"checkerboard\" split up of a generic  Lattice . The only requirement is that the  Lattice  has the following two fields,   n_bonds::Int : total number of bonds (lattice graph edges)  bonds::Matrix{Int} : bond matrix of shape  (n_bonds, 3) . Rows correspond to bonds and columns indicate source site, target site, and bond type in this order.   Of course, one can also manually construct a (more efficient) checkerboard split up by overloading the following function for the specific  Lattice  subtype.  #  MonteCarlo.build_checkerboard     Method .  build_checkerboard(l::Lattice) -  checkerboard, groups, n_groups  Generic checkerboard construction.  The methods returns   checkerboard::Matrix{Int} : size  (3, n_bonds)  where               rows =  source site ,  target site ,  bondid  and cols               correspond to bonds. Sorted (along columns) in such a way               that  checkerboard[3, groups[i]]  are all the bond indices               corresponding to the i-th group.  groups::Vector{UnitRange} : ranges indicating which columns of  checkerboard                               belong to which checkerboard group.  n_groups::Int : number of checkerboard groups.   source", 
            "title": "Checkerboard decomposition"
        }, 
        {
            "location": "/flavors/dqmc/#effective-slice-matrices-and-greens-function", 
            "text": "Combining the symmetric Suzuki-Trotter and checkerboard decomposition we can write (assuming two checkerboard groups  a a  and  b b )   \\begin{align} e^{-\\Delta\\tau \\sum_l T+V(l)}  = e^{\\Delta\\tau T_a/2} e^{\\Delta\\tau T_b/2} \\\\ \\times \\left( \\prod_j e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a} e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau V} \\right) e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}  \\begin{align} e^{-\\Delta\\tau \\sum_l T+V(l)} &= e^{\\Delta\\tau T_a/2} e^{\\Delta\\tau T_b/2} \\\\\n&\\times \\left( \\prod_j e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a} e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau V} \\right) e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a/2} + \\mathcal{O}(\\Delta\\tau^2) \\end{align}   For performance resons we internally work with effective imaginary time slice matrices   \nB_l^{\\text{eff}} = e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a} e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau V}  \nB_l^{\\text{eff}} = e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a} e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau V}   instead of the original  B_l B_l s above.   Warning  Note that one consequence is that the field  dqmc.s.greens  isn't the actual Green's function but an effective one defined by  \\begin{align} G &= \\left( 1 + B_M \\cdots B_1 \\right)^{-1} \\\\\n&= e^{\\Delta\\tau T_a/2} e^{\\Delta\\tau T_b/2} \\left( 1 + B^{\\text{eff}}_M \\cdots B^{\\text{eff}}_1 \\right)^{-1} e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a/2} \\\\\n&= e^{\\Delta\\tau T_a/2} e^{\\Delta\\tau T_b/2} G^{\\text{eff}} e^{-\\Delta\\tau T_b/2} e^{-\\Delta\\tau T_a/2} \\end{align}   To obtain the actual equal-times Green's function, for example for measuring, use  greens(dqmc::DQMC) . Note that although  G\\overset{!}{=}G^\\text{eff} G\\overset{!}{=}G^\\text{eff} } one can readily show that  \\det G = \\det G^{\\text{eff}} \\det G = \\det G^{\\text{eff}}  holds and the Metropolis acceptance is not affected by switching to the effective matrices.", 
            "title": "Effective slice matrices and Green's function"
        }, 
        {
            "location": "/flavors/dqmc/#exports", 
            "text": "", 
            "title": "Exports"
        }, 
        {
            "location": "/flavors/dqmc/#potential-extensions", 
            "text": "Pull requests are very much welcome!   todo", 
            "title": "Potential extensions"
        }, 
        {
            "location": "/lattices/", 
            "text": "Lattices\n\n\nThe package ships with a couple of standard lattices\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nMonteCarlo.Chain\n\n\n1-dimensional chain\n\n\n\n\n\n\nMonteCarlo.SquareLattice\n\n\n2-dimensional square lattice\n\n\n\n\n\n\nMonteCarlo.CubicLattice\n\n\nD-dimensional cubic lattice\n\n\n\n\n\n\n\n\nIt also provides routines to load the following common lattice formats\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nMonteCarlo.ALPSLattice\n\n\nALPS simple lattice graph\n (XML file)\n\n\n\n\n\n\n\n\n\n\nDidn't find your desired lattice?\n\n\nJust implement your own lattice for later use in a model of choice. See \nCustom lattices\n.", 
            "title": "Lattices"
        }, 
        {
            "location": "/lattices/#lattices", 
            "text": "The package ships with a couple of standard lattices     Type  Description      MonteCarlo.Chain  1-dimensional chain    MonteCarlo.SquareLattice  2-dimensional square lattice    MonteCarlo.CubicLattice  D-dimensional cubic lattice     It also provides routines to load the following common lattice formats     Type  Description      MonteCarlo.ALPSLattice  ALPS simple lattice graph  (XML file)", 
            "title": "Lattices"
        }, 
        {
            "location": "/lattices/#didnt-find-your-desired-lattice", 
            "text": "Just implement your own lattice for later use in a model of choice. See  Custom lattices .", 
            "title": "Didn't find your desired lattice?"
        }, 
        {
            "location": "/customize/", 
            "text": "Customize\n\n\n\n\nCustom models\n\n\nAlthough MonteCarlo.jl already ships with famous models, foremost the Ising and Hubbard models, the central idea of the design of the package is to have a (rather) well defined interface between models and Monte Carlo flavors. This way it should be easy for you to extend the package and implement your own physical model (or variations of existing models). You can find the interfaces in the corresponding section of the documentation, for example: \nInterface: Monte Carlo (MC)\n.\n\n\nSometimes examples tell the most, so feel encouraged to have a look at the implementations of the above mentioned models to get a feeling of how to implement your own model.\n\n\n\n\nGeneral remarks for lattice models\n\n\n\n\nSemantics\n\n\nFor lattice models, we define a Model to be a Hamiltonian on a lattice. Therefore, the lattice is part of the model (and not the Monte Carlo flavor). The motivation for this modeling is that the physics of a system does not only depend on the Hamiltonian but also (sometime drastically) on the underlying lattice. This is for example very obvious for spin systems which due to the lattice might become (geometrically) frustrated and show spin liquids physics. Also, from a technical point of view, lattice information is almost exclusively processed in energy calculations which both relate to the Hamiltonian (and therefore the model).\n\n\n\n\nNote\n\n\nWe will generally use the terminology Hamiltonian, energy and so on. However, this doesn't restrict you from defining your model as an Lagrangian with an action in any way as this just corresponds to a one-to-one mapping of interpretations.\n\n\n\n\n\n\nLattice requirements\n\n\nThe Hamiltonian of your model might impose some requirements on the \nLattice\n object that you use as it must provide you with enough lattice information.\n\n\nIt might be educating to look at the structure of the simple \nSquareLattice\n struct.\n\n\nmutable\n \nstruct\n \nSquareLattice\n \n:\n \nAbstractCubicLattice\n\n   \nL\n::\nInt\n\n   \nsites\n::\nInt\n\n   \nneighs\n::\nMatrix\n{\nInt\n}\n \n# row = up, right, down, left; col = siteidx\n\n   \nneighs_cartesian\n::\nArray\n{\nInt\n,\n \n3\n}\n \n# row (1) = up, right, down, left; cols (2,3) = cartesian siteidx\n\n   \nsql\n::\nMatrix\n{\nInt\n}\n\n   \nSquareLattice\n()\n \n=\n \nnew\n()\n\n\nend\n\n\n\n\n\n\nIt only provides access to next nearest neighbors through the arrays \nneighs\n and \nneighs_cartesian\n. If your model's Hamiltonian requires higher order neighbor information, because of, let's say, a next next nearest neighbor hopping term, the \nSquareLattice\n doesn't suffice. You could either extend this Lattice or implement a \nNNSquareLattice\n for example.\n\n\n\n\nCustom lattices\n\n\nAs described in \nCustom models\n a lattice is considered to be part of a model. Hence, most of the requirements for fields of a \nLattice\n subtype come from potential models (see \nLattice requirements\n). Below you'll find information on which fields are mandatory from a Monte Carlo flavor point of view.\n\n\n\n\nMandatory fields\n\n\nAny concrete lattice type, let's call it \nMyLattice\n in the following, must be a subtype of the abstract type \nMonteCarlo.Lattice\n. To work with a Monte Carlo flavor, it \nmust\n internally have at least have the following field,\n\n\n\n\nsites\n: number of lattice sites.\n\n\n\n\nHowever, as already mentioned above depending on the physical model of interest it will typically also have (at least) something like\n\n\n\n\nneighs\n: next nearest neighbors,\n\n\n\n\nas most Hamiltonian will need next nearest neighbor information.\n\n\nThe only reason why such a field isn't generally mandatory is that the Monte Carlo routine doesn't care about the lattice much. Neighbor information is usually only used in the energy (difference) calculation of a particular configuration like done in \nenergy\n or \npropose_local\n which both belong to a \nModel\n.\n\n\n\n\nCustom Monte Carlo flavors\n\n\nComing soon...", 
            "title": "Customize"
        }, 
        {
            "location": "/customize/#customize", 
            "text": "", 
            "title": "Customize"
        }, 
        {
            "location": "/customize/#custom-models", 
            "text": "Although MonteCarlo.jl already ships with famous models, foremost the Ising and Hubbard models, the central idea of the design of the package is to have a (rather) well defined interface between models and Monte Carlo flavors. This way it should be easy for you to extend the package and implement your own physical model (or variations of existing models). You can find the interfaces in the corresponding section of the documentation, for example:  Interface: Monte Carlo (MC) .  Sometimes examples tell the most, so feel encouraged to have a look at the implementations of the above mentioned models to get a feeling of how to implement your own model.", 
            "title": "Custom models"
        }, 
        {
            "location": "/customize/#general-remarks-for-lattice-models", 
            "text": "", 
            "title": "General remarks for lattice models"
        }, 
        {
            "location": "/customize/#semantics", 
            "text": "For lattice models, we define a Model to be a Hamiltonian on a lattice. Therefore, the lattice is part of the model (and not the Monte Carlo flavor). The motivation for this modeling is that the physics of a system does not only depend on the Hamiltonian but also (sometime drastically) on the underlying lattice. This is for example very obvious for spin systems which due to the lattice might become (geometrically) frustrated and show spin liquids physics. Also, from a technical point of view, lattice information is almost exclusively processed in energy calculations which both relate to the Hamiltonian (and therefore the model).   Note  We will generally use the terminology Hamiltonian, energy and so on. However, this doesn't restrict you from defining your model as an Lagrangian with an action in any way as this just corresponds to a one-to-one mapping of interpretations.", 
            "title": "Semantics"
        }, 
        {
            "location": "/customize/#lattice-requirements", 
            "text": "The Hamiltonian of your model might impose some requirements on the  Lattice  object that you use as it must provide you with enough lattice information.  It might be educating to look at the structure of the simple  SquareLattice  struct.  mutable   struct   SquareLattice   :   AbstractCubicLattice \n    L :: Int \n    sites :: Int \n    neighs :: Matrix { Int }   # row = up, right, down, left; col = siteidx \n    neighs_cartesian :: Array { Int ,   3 }   # row (1) = up, right, down, left; cols (2,3) = cartesian siteidx \n    sql :: Matrix { Int } \n    SquareLattice ()   =   new ()  end   It only provides access to next nearest neighbors through the arrays  neighs  and  neighs_cartesian . If your model's Hamiltonian requires higher order neighbor information, because of, let's say, a next next nearest neighbor hopping term, the  SquareLattice  doesn't suffice. You could either extend this Lattice or implement a  NNSquareLattice  for example.", 
            "title": "Lattice requirements"
        }, 
        {
            "location": "/customize/#custom-lattices", 
            "text": "As described in  Custom models  a lattice is considered to be part of a model. Hence, most of the requirements for fields of a  Lattice  subtype come from potential models (see  Lattice requirements ). Below you'll find information on which fields are mandatory from a Monte Carlo flavor point of view.", 
            "title": "Custom lattices"
        }, 
        {
            "location": "/customize/#mandatory-fields", 
            "text": "Any concrete lattice type, let's call it  MyLattice  in the following, must be a subtype of the abstract type  MonteCarlo.Lattice . To work with a Monte Carlo flavor, it  must  internally have at least have the following field,   sites : number of lattice sites.   However, as already mentioned above depending on the physical model of interest it will typically also have (at least) something like   neighs : next nearest neighbors,   as most Hamiltonian will need next nearest neighbor information.  The only reason why such a field isn't generally mandatory is that the Monte Carlo routine doesn't care about the lattice much. Neighbor information is usually only used in the energy (difference) calculation of a particular configuration like done in  energy  or  propose_local  which both belong to a  Model .", 
            "title": "Mandatory fields"
        }, 
        {
            "location": "/customize/#custom-monte-carlo-flavors", 
            "text": "Coming soon...", 
            "title": "Custom Monte Carlo flavors"
        }, 
        {
            "location": "/interfaces/MC/", 
            "text": "Interface: Monte Carlo (MC)\n\n\nAny model that wants to be simulated by means of MC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the Monte Carlo flavor \nMonte Carlo (MC)\n.\n\n\nExample models: \nIsing Model\n\n\n\n\nMandatory fields\n\n\n\n\nl::Lattice\n: any \nLattice\n\n\n\n\n\n\nIndex of all methods\n\n\n\n\nBase.Random.rand\n\n\nMonteCarlo.accept_local!\n\n\nMonteCarlo.conftype\n\n\nMonteCarlo.energy\n\n\nMonteCarlo.finish_observables!\n\n\nMonteCarlo.global_move\n\n\nMonteCarlo.measure_observables!\n\n\nMonteCarlo.prepare_observables\n\n\nMonteCarlo.propose_local\n\n\n\n\n\n\nMandatory methods\n\n\n#\n\n\nMonteCarlo.conftype\n \n \nMethod\n.\n\n\nconftype(::Type{MC}, m::Model)\n\n\n\n\n\nReturns the type of a configuration.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.energy\n \n \nMethod\n.\n\n\nenergy(mc::MC, m::Model, conf)\n\n\n\n\n\nCalculate energy of configuration \nconf\n for Model \nm\n.\n\n\nsource\n\n\n#\n\n\nBase.Random.rand\n \n \nMethod\n.\n\n\nrand(mc::MC, m::Model)\n\n\n\n\n\nDraw random configuration.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.propose_local\n \n \nMethod\n.\n\n\npropose_local\n(\nmc\n::MC\n,\n \nm\n::Model\n,\n \ni\n::Int\n,\n \nconf\n,\n \nE\n::Float64\n)\n \n-\n \ndelta_E\n,\n \ndelta_i\n\n\n\n\n\n\nPropose a local move for lattice site \ni\n of current configuration \nconf\n with energy \nE\n. Returns local move information \ndelta_i\n (e.g. \nnew[i] - conf[i]\n, will be forwarded to \naccept_local!\n) and energy difference \ndelta_E = E_new - E_old\n.\n\n\nSee also \naccept_local!\n.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.accept_local!\n \n \nMethod\n.\n\n\naccept_local\n(\nmc\n::MC\n,\n \nm\n::Model\n,\n \ni\n::Int\n,\n \nconf\n,\n \nE\n::Float64\n,\n \ndelta_i\n,\n \ndelta_E\n::Float64\n)\n\n\n\n\n\n\nAccept a local move for site \ni\n of current configuration \nconf\n with energy \nE\n. Arguments \ndelta_i\n and \ndelta_E\n correspond to output of \npropose_local()\n for that local move.\n\n\nSee also \npropose_local\n.\n\n\nsource\n\n\n\n\nOptional methods\n\n\n#\n\n\nMonteCarlo.global_move\n \n \nMethod\n.\n\n\nglobal_move(mc::MC, m::Model, conf, E::Float64) -\n accepted::Bool\n\n\n\n\n\nPropose a global move for configuration \nconf\n with energy \nE\n. Returns wether the global move has been accepted or not.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.prepare_observables\n \n \nMethod\n.\n\n\nprepare_observables(mc::MC, m::Model) -\n Dict{String, Observable}\n\n\n\n\n\nInitializes observables and returns a \nDict{String, Observable}\n. In the latter, keys are abbreviations for the observables names and values are the observables themselves.\n\n\nSee also \nmeasure_observables!\n and \nfinish_observables!\n.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.measure_observables!\n \n \nMethod\n.\n\n\nmeasure_observables!(mc::MC, m::Model, obs::Dict{String,Observable}, conf, E::Float64)\n\n\n\n\n\nMeasures observables and updates corresponding \nMonteCarloObservable.Observable\n objects in \nobs\n.\n\n\nSee also \nprepare_observables\n and \nfinish_observables!\n.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.finish_observables!\n \n \nMethod\n.\n\n\nfinish_observables!(mc::MC, m::Model, obs::Dict{String,Observable})\n\n\n\n\n\nFinish measurements of observables.\n\n\nSee also \nprepare_observables\n and \nmeasure_observables!\n.\n\n\nsource", 
            "title": "MC"
        }, 
        {
            "location": "/interfaces/MC/#interface-monte-carlo-mc", 
            "text": "Any model that wants to be simulated by means of MC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the Monte Carlo flavor  Monte Carlo (MC) .  Example models:  Ising Model", 
            "title": "Interface: Monte Carlo (MC)"
        }, 
        {
            "location": "/interfaces/MC/#mandatory-fields", 
            "text": "l::Lattice : any  Lattice", 
            "title": "Mandatory fields"
        }, 
        {
            "location": "/interfaces/MC/#index-of-all-methods", 
            "text": "Base.Random.rand  MonteCarlo.accept_local!  MonteCarlo.conftype  MonteCarlo.energy  MonteCarlo.finish_observables!  MonteCarlo.global_move  MonteCarlo.measure_observables!  MonteCarlo.prepare_observables  MonteCarlo.propose_local", 
            "title": "Index of all methods"
        }, 
        {
            "location": "/interfaces/MC/#mandatory-methods", 
            "text": "#  MonteCarlo.conftype     Method .  conftype(::Type{MC}, m::Model)  Returns the type of a configuration.  source  #  MonteCarlo.energy     Method .  energy(mc::MC, m::Model, conf)  Calculate energy of configuration  conf  for Model  m .  source  #  Base.Random.rand     Method .  rand(mc::MC, m::Model)  Draw random configuration.  source  #  MonteCarlo.propose_local     Method .  propose_local ( mc ::MC ,   m ::Model ,   i ::Int ,   conf ,   E ::Float64 )   -   delta_E ,   delta_i   Propose a local move for lattice site  i  of current configuration  conf  with energy  E . Returns local move information  delta_i  (e.g.  new[i] - conf[i] , will be forwarded to  accept_local! ) and energy difference  delta_E = E_new - E_old .  See also  accept_local! .  source  #  MonteCarlo.accept_local!     Method .  accept_local ( mc ::MC ,   m ::Model ,   i ::Int ,   conf ,   E ::Float64 ,   delta_i ,   delta_E ::Float64 )   Accept a local move for site  i  of current configuration  conf  with energy  E . Arguments  delta_i  and  delta_E  correspond to output of  propose_local()  for that local move.  See also  propose_local .  source", 
            "title": "Mandatory methods"
        }, 
        {
            "location": "/interfaces/MC/#optional-methods", 
            "text": "#  MonteCarlo.global_move     Method .  global_move(mc::MC, m::Model, conf, E::Float64) -  accepted::Bool  Propose a global move for configuration  conf  with energy  E . Returns wether the global move has been accepted or not.  source  #  MonteCarlo.prepare_observables     Method .  prepare_observables(mc::MC, m::Model) -  Dict{String, Observable}  Initializes observables and returns a  Dict{String, Observable} . In the latter, keys are abbreviations for the observables names and values are the observables themselves.  See also  measure_observables!  and  finish_observables! .  source  #  MonteCarlo.measure_observables!     Method .  measure_observables!(mc::MC, m::Model, obs::Dict{String,Observable}, conf, E::Float64)  Measures observables and updates corresponding  MonteCarloObservable.Observable  objects in  obs .  See also  prepare_observables  and  finish_observables! .  source  #  MonteCarlo.finish_observables!     Method .  finish_observables!(mc::MC, m::Model, obs::Dict{String,Observable})  Finish measurements of observables.  See also  prepare_observables  and  measure_observables! .  source", 
            "title": "Optional methods"
        }, 
        {
            "location": "/interfaces/DQMC/", 
            "text": "Interface: Determinant Quantum Monte Carlo (DQMC)\n\n\nAny model that wants to be simulated by means of DQMC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the determinant Monte Carlo flavor \nDeterminant Quantum Monte Carlo (DQMC)\n.\n\n\nExample models: \nAttractive Hubbard Model\n\n\n\n\nMandatory fields\n\n\n\n\nl::Lattice\n: any \nLattice\n\n\nflv::Int\n: number of distinct fermion flavors (e.g. spins, bands, etc.). The Green's function will have shape \n(flv*N, flv*N)\n, where \nN\n is the number of sites. Note that different fermion flavors are often related by symmetry and it's advisable to use this symmetry to work with smaller Green's function matrices. Have a look at the \nAttractive Hubbard Model\n as an example where \nflv=1\n although it has spinful fermions.\n\n\n\n\n\n\nIndex of all methods\n\n\n\n\nBase.Random.rand\n\n\nMonteCarlo.accept_local\n\n\nMonteCarlo.conftype\n\n\nMonteCarlo.energy_boson\n\n\nMonteCarlo.finish_observables!\n\n\nMonteCarlo.greenseltype\n\n\nMonteCarlo.hopping_matrix\n\n\nMonteCarlo.interaction_matrix_exp!\n\n\nMonteCarlo.measure_observables!\n\n\nMonteCarlo.prepare_observables\n\n\nMonteCarlo.propose_local\n\n\n\n\n\n\nMandatory methods\n\n\n#\n\n\nMonteCarlo.conftype\n \n \nMethod\n.\n\n\nconftype(::Type{DQMC}, m::Model)\n\n\n\n\n\nReturns the type of a configuration.\n\n\nsource\n\n\n#\n\n\nBase.Random.rand\n \n \nMethod\n.\n\n\nrand(mc::DQMC, m::Model)\n\n\n\n\n\nDraw random configuration.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.hopping_matrix\n \n \nMethod\n.\n\n\nhopping_matrix(mc::DQMC, m::Model)\n\n\n\n\n\nCalculates the hopping matrix \nT_{i\\sigma, j\\sigma '}\nT_{i\\sigma, j\\sigma '}\n where \ni, j\ni, j\n are site indices and \n\\sigma , \\sigma '\n\\sigma , \\sigma '\n are flavor indices (e.g. spin indices). The hopping matrix should also contain potential chemical potential terms on the diagonal.\n\n\nA matrix element is the hopping amplitude for a hopping process: \nj,\\sigma ' \\rightarrow i,\\sigma\nj,\\sigma ' \\rightarrow i,\\sigma\n.\n\n\nRegarding the order of indices, if \nT[i, \u03c3, j, \u03c3']\n is your desired 4D hopping array, then \nreshape(T, (n_sites * n_flavors, :))\n is the hopping matrix.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.interaction_matrix_exp!\n \n \nFunction\n.\n\n\ninteraction_matrix_exp!(mc::DQMC, m::Model, result::Matrix, conf, slice::Int, power::Float64=1.) -\n nothing\n\n\n\n\n\nCalculate the interaction matrix exponential \nexpV = exp(- power * delta_tau * V(slice))\n and store it in \nresult::Matrix\n. Potential chemical potential terms should be part of the \nhopping_matrix\n and not the interaction.\n\n\nThis is a performance critical method and one might consider efficient in-place (in \nresult\n) construction.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.propose_local\n \n \nMethod\n.\n\n\npropose_local\n(\nmc\n::DQMC\n,\n \nm\n::Model\n,\n \ni\n::Int\n,\n \nconf\n,\n \nE_boson\n::Float64\n)\n \n-\n \ndetratio\n,\n \ndelta_E_boson\n,\n \ndelta\n\n\n\n\n\n\nPropose a local move for lattice site \ni\n of current configuration \nconf\n with boson energy \nE_boson\n. Returns the Green's function determinant ratio, the boson energy difference \ndelta_E_boson = delta_E_boson_new - delta_E_boson\n, and additional local move information \ndelta\n (will be forwarded to \naccept_local!\n).\n\n\nSee also \naccept_local!\n.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.accept_local\n \n \nMethod\n.\n\n\naccept_local\n(\nmc\n::DQMC\n,\n \nm\n::Model\n,\n \ni\n::Int\n,\n \nslice\n::Int\n,\n \nconf\n,\n \ndelta\n,\n \ndetratio\n,\n \ndelta_E_boson\n)\n\n\n\n\n\n\nAccept a local move for site \ni\n at imaginary time slice \nslice\n of current configuration \nconf\n with energy \nE\n. Arguments \ndelta\n, \ndetratio\n and \ndelta_E_boson\n correspond to output of \npropose_local()\n for that local move.\n\n\nSee also \npropose_local\n.\n\n\nsource\n\n\n\n\nOptional methods\n\n\n#\n\n\nMonteCarlo.greenseltype\n \n \nMethod\n.\n\n\ngreenseltype(::Type{DQMC}, m::Model)\n\n\n\n\n\nReturns the type of the elements of the Green's function matrix. Defaults to \nComplex128\n.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.energy_boson\n \n \nMethod\n.\n\n\nenergy(mc::DQMC, m::Model, conf)\n\n\n\n\n\nCalculate bosonic part (non-Green's function determinant part) of energy for configuration \nconf\n for Model \nm\n.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.prepare_observables\n \n \nMethod\n.\n\n\nprepare_observables(mc::DQMC, m::Model) -\n Dict{String, Observable}\n\n\n\n\n\nInitializes observables and returns a \nDict{String, Observable}\n. In the latter, keys are abbreviations for the observables names and values are the observables themselves.\n\n\nSee also \nmeasure_observables!\n and \nfinish_observables!\n.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.measure_observables!\n \n \nMethod\n.\n\n\nmeasure_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable}, conf)\n\n\n\n\n\nMeasures observables and updates corresponding \nMonteCarloObservable.Observable\n objects in \nobs\n.\n\n\nSee also \nprepare_observables\n and \nfinish_observables!\n.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.finish_observables!\n \n \nMethod\n.\n\n\nfinish_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable})\n\n\n\n\n\nFinish measurements of observables.\n\n\nSee also \nprepare_observables\n and \nmeasure_observables!\n.\n\n\nsource", 
            "title": "DQMC"
        }, 
        {
            "location": "/interfaces/DQMC/#interface-determinant-quantum-monte-carlo-dqmc", 
            "text": "Any model that wants to be simulated by means of DQMC must implement the following interface. Below you find all semantic definitions and precise signatures of mandatory fields and mandatory and optional methods that any model should implement to work with the determinant Monte Carlo flavor  Determinant Quantum Monte Carlo (DQMC) .  Example models:  Attractive Hubbard Model", 
            "title": "Interface: Determinant Quantum Monte Carlo (DQMC)"
        }, 
        {
            "location": "/interfaces/DQMC/#mandatory-fields", 
            "text": "l::Lattice : any  Lattice  flv::Int : number of distinct fermion flavors (e.g. spins, bands, etc.). The Green's function will have shape  (flv*N, flv*N) , where  N  is the number of sites. Note that different fermion flavors are often related by symmetry and it's advisable to use this symmetry to work with smaller Green's function matrices. Have a look at the  Attractive Hubbard Model  as an example where  flv=1  although it has spinful fermions.", 
            "title": "Mandatory fields"
        }, 
        {
            "location": "/interfaces/DQMC/#index-of-all-methods", 
            "text": "Base.Random.rand  MonteCarlo.accept_local  MonteCarlo.conftype  MonteCarlo.energy_boson  MonteCarlo.finish_observables!  MonteCarlo.greenseltype  MonteCarlo.hopping_matrix  MonteCarlo.interaction_matrix_exp!  MonteCarlo.measure_observables!  MonteCarlo.prepare_observables  MonteCarlo.propose_local", 
            "title": "Index of all methods"
        }, 
        {
            "location": "/interfaces/DQMC/#mandatory-methods", 
            "text": "#  MonteCarlo.conftype     Method .  conftype(::Type{DQMC}, m::Model)  Returns the type of a configuration.  source  #  Base.Random.rand     Method .  rand(mc::DQMC, m::Model)  Draw random configuration.  source  #  MonteCarlo.hopping_matrix     Method .  hopping_matrix(mc::DQMC, m::Model)  Calculates the hopping matrix  T_{i\\sigma, j\\sigma '} T_{i\\sigma, j\\sigma '}  where  i, j i, j  are site indices and  \\sigma , \\sigma ' \\sigma , \\sigma '  are flavor indices (e.g. spin indices). The hopping matrix should also contain potential chemical potential terms on the diagonal.  A matrix element is the hopping amplitude for a hopping process:  j,\\sigma ' \\rightarrow i,\\sigma j,\\sigma ' \\rightarrow i,\\sigma .  Regarding the order of indices, if  T[i, \u03c3, j, \u03c3']  is your desired 4D hopping array, then  reshape(T, (n_sites * n_flavors, :))  is the hopping matrix.  source  #  MonteCarlo.interaction_matrix_exp!     Function .  interaction_matrix_exp!(mc::DQMC, m::Model, result::Matrix, conf, slice::Int, power::Float64=1.) -  nothing  Calculate the interaction matrix exponential  expV = exp(- power * delta_tau * V(slice))  and store it in  result::Matrix . Potential chemical potential terms should be part of the  hopping_matrix  and not the interaction.  This is a performance critical method and one might consider efficient in-place (in  result ) construction.  source  #  MonteCarlo.propose_local     Method .  propose_local ( mc ::DQMC ,   m ::Model ,   i ::Int ,   conf ,   E_boson ::Float64 )   -   detratio ,   delta_E_boson ,   delta   Propose a local move for lattice site  i  of current configuration  conf  with boson energy  E_boson . Returns the Green's function determinant ratio, the boson energy difference  delta_E_boson = delta_E_boson_new - delta_E_boson , and additional local move information  delta  (will be forwarded to  accept_local! ).  See also  accept_local! .  source  #  MonteCarlo.accept_local     Method .  accept_local ( mc ::DQMC ,   m ::Model ,   i ::Int ,   slice ::Int ,   conf ,   delta ,   detratio ,   delta_E_boson )   Accept a local move for site  i  at imaginary time slice  slice  of current configuration  conf  with energy  E . Arguments  delta ,  detratio  and  delta_E_boson  correspond to output of  propose_local()  for that local move.  See also  propose_local .  source", 
            "title": "Mandatory methods"
        }, 
        {
            "location": "/interfaces/DQMC/#optional-methods", 
            "text": "#  MonteCarlo.greenseltype     Method .  greenseltype(::Type{DQMC}, m::Model)  Returns the type of the elements of the Green's function matrix. Defaults to  Complex128 .  source  #  MonteCarlo.energy_boson     Method .  energy(mc::DQMC, m::Model, conf)  Calculate bosonic part (non-Green's function determinant part) of energy for configuration  conf  for Model  m .  source  #  MonteCarlo.prepare_observables     Method .  prepare_observables(mc::DQMC, m::Model) -  Dict{String, Observable}  Initializes observables and returns a  Dict{String, Observable} . In the latter, keys are abbreviations for the observables names and values are the observables themselves.  See also  measure_observables!  and  finish_observables! .  source  #  MonteCarlo.measure_observables!     Method .  measure_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable}, conf)  Measures observables and updates corresponding  MonteCarloObservable.Observable  objects in  obs .  See also  prepare_observables  and  finish_observables! .  source  #  MonteCarlo.finish_observables!     Method .  finish_observables!(mc::DQMC, m::Model, obs::Dict{String,Observable})  Finish measurements of observables.  See also  prepare_observables  and  measure_observables! .  source", 
            "title": "Optional methods"
        }, 
        {
            "location": "/methods/general/", 
            "text": "Methods: General\n\n\nBelow you find all general exports.\n\n\n\n\nIndex\n\n\n\n\nMonteCarlo.observables\n\n\nMonteCarlo.reset!\n\n\n\n\n\n\nDocumentation\n\n\n#\n\n\nMonteCarlo.observables\n \n \nMethod\n.\n\n\nobservables(mc::MonteCarloFlavor)\n\n\n\n\n\nGet a list of all observables defined for a given Monte Carlo simulation.\n\n\nReturns a \nDict{String, String}\n where values are the observables names and keys are short versions of those names. The keys can be used to collect correponding observable objects from the Monte Carlo simulation, e.g. like \nmc.obs[key]\n.\n\n\nNote, there is no need to implement this function for a custom \nMonteCarloFlavor\n.\n\n\nsource\n\n\n#\n\n\nMonteCarlo.reset!\n \n \nMethod\n.\n\n\nreset!(mc::MonteCarloFlavor)\n\n\n\n\n\nResets the Monte Carlo simulation \nmc\n. Previously set parameters will be retained.\n\n\nsource", 
            "title": "General exports"
        }, 
        {
            "location": "/methods/general/#methods-general", 
            "text": "Below you find all general exports.", 
            "title": "Methods: General"
        }, 
        {
            "location": "/methods/general/#index", 
            "text": "MonteCarlo.observables  MonteCarlo.reset!", 
            "title": "Index"
        }, 
        {
            "location": "/methods/general/#documentation", 
            "text": "#  MonteCarlo.observables     Method .  observables(mc::MonteCarloFlavor)  Get a list of all observables defined for a given Monte Carlo simulation.  Returns a  Dict{String, String}  where values are the observables names and keys are short versions of those names. The keys can be used to collect correponding observable objects from the Monte Carlo simulation, e.g. like  mc.obs[key] .  Note, there is no need to implement this function for a custom  MonteCarloFlavor .  source  #  MonteCarlo.reset!     Method .  reset!(mc::MonteCarloFlavor)  Resets the Monte Carlo simulation  mc . Previously set parameters will be retained.  source", 
            "title": "Documentation"
        }
    ]
}